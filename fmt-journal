#!/usr/bin/env bash

set -euo pipefail

# --- Function for usage message ---
usage() {
    echo "Usage: $0 [-o <output-file>] <journal-file>" >&2
    exit 1
}

# --- Default values ---
output_file=""
input_file=""

# --- Function for tldr-style help ---
tldr_help() {
    cat << EOF
fmt-journal

Format an hledger journal file by printing its header and formatted body.

- View formatted journal in the terminal (stdout):
  ./fmt-journal <journal-file>

- Save formatted output to a new file:
  ./fmt-journal <journal-file> > <new-file.journal>

- Overwrite the original file safely (in-place formatting):
  ./fmt-journal -o <journal-file> <journal-file>

EOF
    exit 0
}

# --- Argument Parsing ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        -o)
            if [[ -n "$2" ]]; then
                output_file="$2"
                shift 2
            else
                echo "Error: -o requires a filename." >&2
                usage
            fi
            ;;
        --tldr)
            tldr_help
            ;;
        -h|--help)
            usage
            ;;
        -*)
            echo "Error: Unknown option '$1'" >&2
            usage
            ;;
        *)
            if [[ -z "$input_file" ]]; then
                input_file="$1"
                shift
            else
                echo "Error: Input file specified more than once." >&2
                usage
            fi
            ;;
    esac
done

# --- Validation ---
if [[ -z "$input_file" ]]; then
    echo "Error: No input file specified." >&2
    usage
fi

if [[ ! -f "$input_file" ]]; then
    echo "Error: Input file not found: $input_file" >&2
    exit 1
fi


# --- Core Logic ---

# Find the line number of the first transaction (the first line starting with a date).
# If no transaction is found, it will process the whole file as header.
first_txn_line=$(grep -n -m 1 '^[0-9]\{4\}-' "$input_file" | cut -d: -f1)

# Separate header and body
if [[ -z "$first_txn_line" ]]; then
    # No transactions found, treat whole file as header
    header=$(cat "$input_file")
    body=""
else
    header_line_count=$((first_txn_line - 1))
    header=$(head -n "$header_line_count" "$input_file")
    body=$(tail -n +$first_txn_line "$input_file")
fi

# Create a temporary file for hledger's formatted output
tmp_hledger_out=$(mktemp)
trap 'rm -f "$tmp_hledger_out"' EXIT

# Format only the body of the journal to the temporary file
# If body is empty, this will create an empty temp file.
echo "$body" | hledger print -x -f - -o "$tmp_hledger_out"


# --- Output Handling ---
if [[ -n "$output_file" ]]; then
    # To handle in-place editing safely, we build the full output in a
    # separate temp file and then move it into place.
    tmp_final_out=$(mktemp)
    trap 'rm -f "$tmp_hledger_out" "$tmp_final_out"' EXIT # Update trap

    # Build the final output, ensuring a single blank line between header and body
    printf "%s" "$header" > "$tmp_final_out"
    if [[ -n "$header" && -s "$tmp_hledger_out" ]]; then
        # Add exactly one blank line if header is not empty and body is not empty
        printf "\n\n" >> "$tmp_final_out"
    fi
    cat "$tmp_hledger_out" >> "$tmp_final_out"

    # Move the final output to the destination
    mv "$tmp_final_out" "$output_file"
else
    # Output to stdout, ensuring a single blank line between header and body
    printf "%s" "$header"
    if [[ -n "$header" && -s "$tmp_hledger_out" ]]; then
        # Add exactly one blank line if header is not empty and body is not empty
        printf "\n\n"
    fi
    cat "$tmp_hledger_out"
fi
